{
    "summary": "Find max profit with k transactions",
    "question": "Given an array of stock prices and an integer k, calculate the maximum profit achievable with at most k transactions, adhering to the restriction of selling before buying again.",
    "example": "Input: k = 2, prices = [2,4,1]; Output: 2. Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Input: k = 2, prices = [3,2,6,5,0,3]; Output: 7. Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.",
    "constraint": "0 <= k <= 100; 0 <= prices.length <= 1000; 0 <= prices[i] <= 1000",
    "followup": "",
    "title": "Best Time To Buy And Sell Stock Iv",
    "leetcode_url": "https://leetcode.com/problems/Best-Time-to-Buy-and-Sell-Stock-IV/",
    "difficulty": "Hard",
    "starter_code": "\n    ```python\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    "
}