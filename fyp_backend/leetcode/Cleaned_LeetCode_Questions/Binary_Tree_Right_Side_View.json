{
    "summary": "Right side view of tree",
    "question": "Given the root of a binary tree, return the values of the nodes visible from the right side, ordered from top to bottom.",
    "example": "Input: root = [1,2,3,null,5,null,4] Output: [1,3,4]. Input: root = [1,null,3] Output: [1,3]. Input: root = [] Output: []",
    "constraint": "The number of nodes in the tree is in the range [0, 100]. Node values are between -100 and 100.",
    "followup": "",
    "title": "Binary Tree Right Side View",
    "leetcode_url": "https://leetcode.com/problems/Binary-Tree-Right-Side-View/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef rightSideView(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n\n        for i in range(level_size):\n            current = queue.pop(0)\n\n            if i == level_size - 1:\n                result.append(current.val)\n            \n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result\n```\n    \n    The function uses a breadth-first search (BFS) approach to traverse the binary tree level by level. We use a queue to keep track of nodes at the current level. \n\nThe algorithm starts by adding the root node to the queue. Then, while the queue is not empty, we iteratively process each level. During each iteration, we calculate the size of the current level, then loop through each node of that level. If we reach the last node of the current level, i.e. `(i == level_size - 1)`, we add that node's value to the result list. After processing the current node, we add its left and right children to the queue if they exist. \n\nAfter traversing the entire tree, we return the result list. The algorithm is the same for all languages, with the only differences being syntactical.\n    "
}