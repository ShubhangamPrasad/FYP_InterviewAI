{
    "summary": "Find combinations summing to target",
    "question": "Given an array of distinct integers 'candidates' and a target integer 'target', return a list of all unique combinations where the chosen numbers sum to the target. Each number can be used unlimited times, and combinations must be unique based on frequency.",
    "example": "Input: candidates = [2,3,6,7], target = 7; Output: [[2,2,3],[7]]\nInput: candidates = [2,3,5], target = 8; Output: [[2,2,2,2],[2,3,3],[3,5]]\nInput: candidates = [2], target = 1; Output: []\nInput: candidates = [1], target = 1; Output: [[1]]\nInput: candidates = [1], target = 2; Output: [[1,1]]",
    "constraint": "1 <= candidates.length <= 30; 1 <= candidates[i] <= 200; All elements of 'candidates' are distinct; 1 <= target <= 500; Maximum 150 unique combinations for any input.",
    "followup": "",
    "title": "Combination Sum",
    "leetcode_url": "https://leetcode.com/problems/Combination-Sum/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\ndef combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    "
}