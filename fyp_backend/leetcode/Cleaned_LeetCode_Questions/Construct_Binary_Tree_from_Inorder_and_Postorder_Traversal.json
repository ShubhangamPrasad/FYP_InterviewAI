{
    "summary": "Reconstruct binary tree from traversals",
    "question": "Given two integer arrays 'inorder' and 'postorder', representing the inorder and postorder traversals of a binary tree respectively, construct and return the binary tree.",
    "example": "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] -> Output: [3,9,20,null,null,15,7]; Input: inorder = [-1], postorder = [-1] -> Output: [-1]",
    "constraint": "1 <= inorder.length <= 3000; postorder.length == inorder.length; -3000 <= inorder[i], postorder[i] <= 3000; inorder and postorder consist of unique values; All values in postorder appear in inorder; The given traversals are valid representations of the binary tree.",
    "followup": "",
    "title": "Construct Binary Tree From Inorder And Postorder Traversal",
    "leetcode_url": "https://leetcode.com/problems/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        def _build(in_left, in_right, post_root):\n            if in_left > in_right:\n                return None\n            \n            root = TreeNode(postorder[post_root])\n\n            inorder_root_index = index_map[root.val]\n            left_tree_size = inorder_root_index - in_left\n\n            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)\n            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)\n\n            return root\n\n        index_map = {val: i for i, val in enumerate(inorder)}\n        return _build(0, len(inorder) - 1, len(postorder) - 1)\n```\n    \n    We are given the inorder and postorder traversals of a binary tree, and the task is to reconstruct the binary tree from this information. In the postorder traversal, the last element is the root of the tree. Knowing the root, we can divide the inorder traversal into left and right subtrees. With the knowledge of the left subtree size, we can divide the postorder traversal into left and right subtrees as well. We can then recursively build the left and right subtrees, and construct the tree accordingly.\n\nThe provided solution maintains a hashmap to keep the indexes of elements in the inorder traversal for easy access during the construction. It uses a helper function `_build` to carry out the recursive construction. The `_build` function takes in the range of elements to be considered in both inorder and postorder traversals and recursively constructs the tree, by dividing the inorder and postorder ranges into left and right subtrees, using the root found in the postorder traversal.\n    "
}