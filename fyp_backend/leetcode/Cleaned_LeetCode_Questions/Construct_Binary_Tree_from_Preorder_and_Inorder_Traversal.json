{
    "summary": "Construct binary tree from traversals",
    "question": "Given two integer arrays preorder and inorder, construct and return the binary tree represented by these traversals.",
    "example": "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]; Output: [3,9,20,null,null,15,7]. Input: preorder = [-1], inorder = [-1]; Output: [-1]",
    "constraint": "1 <= preorder.length <= 3000, inorder.length == preorder.length, -3000 <= preorder[i], inorder[i] <= 3000. Both arrays consist of unique values. Each value in inorder also appears in preorder. preorder and inorder are guaranteed to represent valid traversals of the same tree.",
    "followup": "",
    "title": "Construct Binary Tree From Preorder And Inorder Traversal",
    "leetcode_url": "https://leetcode.com/problems/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(preorder, inorder):\n    def construct_tree(in_left, in_right):\n        nonlocal pre_idx\n        if in_left > in_right:\n            return None\n\n        root_val = preorder[pre_idx]\n        root = TreeNode(root_val)\n        idx = in_map[root_val]\n\n        pre_idx += 1\n        root.left = construct_tree(in_left, idx - 1)\n        root.right = construct_tree(idx + 1, in_right)\n\n        return root\n\n    in_map = {val: idx for idx, val in enumerate(inorder)}\n    pre_idx = 0\n    return construct_tree(0, len(inorder) - 1)\n```\n    \n    The algorithm uses Depth-First Search (DFS) on both the preorder and inorder traversal results. This algorithm iteratively breaks the inorder sequence into left and right subtrees using the preorder array. The basic idea is that the first element of preorder traversal will always be the root of the tree. Then, we can find that root node's index in the inorder traversal, and create the left subtree from the elements to the left of the index, and the right subtree from the elements to the right of the index. Then we continue this process recursively.\n\nTo improve the performance of the search for the index, we can use a map (in C++, Java and JavaScript) or a dictionary (in Python) to store the indices of all elements in the inorder traversal. This way, we don't need to traverse the inorder array every time to find the index of the current element.\n\nSince we're doing this for Python, Java, C++ and JavaScript, some data structures might look a bit different and have different functions to do the same action, but the algorithm used in all languages is the same.\n\n- Preorder traversal is given as an array in all implementations.\n- Inorder traversal is given as an array in all implementations.\n- A map is used to store the indices for inorder traversal in C++, Java, and JavaScript, while a dictionary is used in Python.\n- A helper function is used to recursively construct the tree.\n- For Python and JavaScript, the scope of pre_idx is made non-local, so it does not require additional arguments.\n\nThe resulting functions return the root node of the reconstructed binary tree.\n    "
}