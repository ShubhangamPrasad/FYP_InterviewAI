{
    "summary": "Construct Quad-Tree from matrix",
    "question": "Given an n x n matrix of 0's and 1's, construct a Quad-Tree representing the matrix as per the rules of Quad-Tree: if all values in a sub-grid are same, create a leaf node; otherwise, recursively divide the grid into four sub-grids.",
    "example": "Input: grid = [[0,1],[1,0]]; Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]; Explanation: Quad-Tree is constructed by recursively dividing the grid and storing values in nodes.",
    "constraint": "n == grid.length == grid[i].length; n == 2^x where 0 <= x <= 6",
    "followup": "Can this implementation handle larger grids efficiently?",
    "title": "Construct Quad Tree",
    "leetcode_url": "https://leetcode.com/problems/Construct-Quad-Tree/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef build(grid, row, col, size):\n    if size == 1:\n        return Node(grid[row][col] == 1, True, None, None, None, None)\n    half = size // 2\n    topLeft = build(grid, row, col, half)\n    topRight = build(grid, row, col + half, half)\n    bottomLeft = build(grid, row + half, col, half)\n    bottomRight = build(grid, row + half, col + half, half)\n    if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and topLeft.val == topRight.val and topLeft.val == bottomLeft.val and topLeft.val == bottomRight.val:\n        return topLeft\n    return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\n\ndef construct(grid):\n    return build(grid, 0, 0, len(grid))\n```\n    \n    The algorithm first checks if the size of the grid is 1, in which case it returns a new Node with the value of the grid and sets the isLeaf attribute to True. Else, the algorithm calculates the half size of the matrix and recursively builds the topLeft, topRight, bottomLeft, and bottomRight. If all of them are leaf nodes and their values are the same, the current node takes the value of topLeft and the isLeaf attribute is set to True; otherwise, it keeps building the quad-tree structure for each sub-grid.\n\nThe overall algorithm is recursive and implements a divide-and-conquer technique to build the quad-tree structure.\n    "
}