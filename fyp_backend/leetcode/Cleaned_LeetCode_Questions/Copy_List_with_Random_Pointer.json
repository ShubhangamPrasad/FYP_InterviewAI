{
    "summary": "Deep copy linked list problem",
    "question": "Construct a deep copy of a linked list where each node has a random pointer, ensuring pointers in the copied list represent the same state as the original without referring to original nodes.",
    "example": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]; Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]]; Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]]; Input: head = [] Output: []",
    "constraint": "0 <= n <= 1000; -10000 <= Node.val <= 10000; Node.random can be null or point to any node in the list.",
    "followup": "",
    "title": "Copy List With Random Pointer",
    "leetcode_url": "https://leetcode.com/problems/Copy-List-with-Random-Pointer/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n        \ndef copyRandomList(head):\n    if not head:\n        return None\n\n    curr = head\n    while curr:\n        temp = Node(curr.val)\n        temp.next = curr.next\n        curr.next = temp\n        curr = curr.next.next\n\n    curr = head\n    while curr:\n        if curr.random:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n\n    orig = head\n    copy = head.next\n    copy_head = copy\n\n    while orig and copy:\n        orig.next = copy.next\n        orig = orig.next\n        if orig:\n            copy.next = orig.next\n            copy = copy.next\n\n    return copy_head\n```\n    \n    The algorithm follows these steps:\n\n1. Iterate through the original linked list, creating new nodes with the same value as the original nodes and insert them right after the original node in the original list. Now we have an interleaved list where each original node is followed by its copy.\n2. Iterate through the interleaved list and assign the `random` pointers of the new nodes. Since the new nodes are right after their corresponding originals, we can easily set the `random` pointers for the new nodes based on the `random` pointers of the original nodes.\n3. Separate the interleaved list into two separate lists - the original list and the copied list.\n\nThis algorithm creates a deep copy of the linked list with random pointers without using any extra space or data structures other than the nodes themselves. The running time complexity is O(n) as we do three separate O(n) passes through the linked list.\n    "
}