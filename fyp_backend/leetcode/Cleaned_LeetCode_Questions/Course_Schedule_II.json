{
    "summary": "Determine course completion order",
    "question": "Find the order of courses to complete all courses given a list of prerequisites, or return an empty array if impossible.",
    "example": "Input: numCourses = 2, prerequisites = [[1,0]]; Output: [0,1]. Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]; Output: [0,2,1,3]. Input: numCourses = 1, prerequisites = []; Output: [0].",
    "constraint": "1 <= numCourses <= 2000, 0 <= prerequisites.length <= numCourses * (numCourses - 1), prerequisites[i].length == 2, 0 <= ai, bi < numCourses, ai != bi, all pairs [ai, bi] are distinct.",
    "followup": "",
    "title": "Course Schedule Ii",
    "leetcode_url": "https://leetcode.com/problems/Course-Schedule-II/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nfrom collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []\n```\n\n    \n    This problem can be solved using the Topological Sort algorithm, which works in the following way:\n1. Calculate the in-degree (number of incoming edges) of each node/course (use an array called `inDegree`).\n2. Initialize an adjacency list, `adjList`, to store the outgoing courses from a prerequisite course.\n3. Fill `adjList` while iterating through the prerequisites array.\n4. Create a queue, `q`, and enqueue all the nodes whose in-degree is 0; these nodes represent the starting points in this topological sort.\n5. Initialize an array or list called `order` to store the final ordering.\n6. While `q` is not empty, perform the following steps:\n    - Dequeue the front node `curr`.\n    - Append `curr` to the `order`.\n    - Iterate through all the outgoing courses (neighbors) of `curr`. For each neighboring node `next`, decrease the in-degree of `next` by 1. If the in-degree of `next` becomes 0, enqueue `next` to `q`.\n7. Finally, if the length of the `order` is equal to the total number of courses, return the `order`. Otherwise, return an empty array/list, indicating that it is impossible to finish all the courses.\n    "
}