{
    "summary": "Manage words and perform search",
    "question": "Design a class called WordDictionary that supports adding words and searching for matches where the search string may contain '.' as a wildcard.",
    "example": "Input: [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"] [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]] Output: [null,null,null,null,false,true,true,true]",
    "constraint": "1 <= word.length <= 500; addWord words consist of lowercase English letters; search words consist of '.' or lowercase English letters; no more than 50000 calls to addWord and search combined.",
    "followup": "",
    "title": "Design Add And Search Words Data Structure",
    "leetcode_url": "https://leetcode.com/problems/Design-Add-and-Search-Words-Data-Structure/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_word = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        current = self.root\n        for c in word:\n            index = ord(c) - ord('a')\n            if current.children[index] is None:\n                current.children[index] = TrieNode()\n            current = current.children[index]\n        current.is_word = True\n\n    def search(self, word: str) -> bool:\n        return self._search_helper(self.root, word, 0)\n\n    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:\n        if index == len(word):\n            return node.is_word\n\n        if word[index] == '.':\n            for child_node in node.children:\n                if child_node is not None and self._search_helper(child_node, word, index + 1):\n                    return True\n            return False\n        else:\n            child_node = node.children[ord(word[index]) - ord('a')]\n            if child_node is None:\n                return False\n            return self._search_helper(child_node, word, index + 1)\n```\n\n    \n    We use a Trie data structure to store the words. Each Trie node has an array of child pointers for all lowercase English letters (size 26) and a boolean flag `is_word` indicating if the word ends at this node. Initially, all child pointers are set to null, and `is_word` is set to false.\n\nWhen we add a word, we walk through the Trie, creating new child nodes if necessary, and set `is_word` to true for the last Trie node representing the word's last character.\n\nWhen we search for a word, we use a helper function that takes the current Trie node, the word, and the current position in the word. If the current character in the word is a dot (`.`), we search for any matching character by iterating through all its children, recursively calling the helper function with the next position in the word. If the current character in the word is a lowercase letter, we proceed to the corresponding child node and continue the search.\n\nAt any point, if we reach the word's end, we check if the `is_word` of the current Trie node is true. If it is, we found a match. Otherwise, the search continues.\n    "
}