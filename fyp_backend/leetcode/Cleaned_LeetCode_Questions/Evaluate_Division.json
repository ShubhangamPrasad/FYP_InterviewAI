{
    "summary": "Evaluate division based on equations",
    "question": "Given equations and values, determine the results of queries on division relationships between variables. Return -1.0 if the result cannot be determined.",
    "example": "Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]",
    "constraint": "1 <= equations.length <= 20, equations[i].length == 2, 1 <= Ai.length, Bi.length <= 5, 0.0 < values[i] <= 20.0, 1 <= queries.length <= 20, queries[i].length == 2, 1 <= Cj.length, Dj.length <= 5. Variables are lowercase English letters and digits.",
    "followup": "",
    "title": "Evaluate Division",
    "leetcode_url": "https://leetcode.com/problems/Evaluate-Division/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(s1, s2, graph):\n    if s1 not in graph or s2 not in graph:\n        return -1.0\n    if s1 == s2:\n        return 1.0\n    \n    for neighbor, weight in graph[s1]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            temp = dfs(neighbor, s2, graph)\n            if temp > 0:\n                return weight * temp\n    return -1.0\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(list)\n    for (s1, s2), value in zip(equations, values):\n        graph[s1].append((s2, value))\n        graph[s2].append((s1, 1 / value))\n    \n    ans = []\n    for s1, s2 in queries:\n        visited = set()\n        ans.append(dfs(s1, s2, graph))\n    return ans\n```\n    \n    First, we create an adjacency list `graph` to represent the relationship between variables where `graph[A].push({B, k})` for equation `A / B = k`. In each query, we try to find the path from `Cj` to `Dj` using a Depth-First Search (DFS) algorithm. In case the path exists, we return the value of `Cj / Dj`. If there is no path, return -1.0.\n\n1. Create an empty graph (implemented as a hashmap) to store the variable pairs and values.\n2. Iterate through the equations and values arrays, adding an edge between each Ai and Bi with its corresponding value to the graph.\n3. Define a helper function (DFS) for traversing the graph and calculating the answer for a given query.\n4. Iterate through the queries and apply the DFS function to find the answers. Save the results in an array and return it.\n\nThe time complexity of this algorithm is O(N * P) where N is the number of equations and P is the number of queries. This is because for each query, we may need to visit all the nodes in our graph. The space complexity is O(N) which also corresponds to the size of the graph.\n    "
}