{
    "summary": "Implement a Trie data structure",
    "question": "Design and implement a Trie class with insert, search, and startsWith functionalities.",
    "example": "Input: [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"], [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output: [null, null, true, false, true, null, true] Explanation: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // True trie.search(\"app\"); // False trie.startsWith(\"app\"); // True trie.insert(\"app\"); trie.search(\"app\"); // True",
    "constraint": "1 <= word.length, prefix.length <= 2000; word and prefix consist only of lowercase English letters; at most 30,000 calls to insert, search, and startsWith methods combined.",
    "followup": "How can we optimize trie memory for large datasets?",
    "title": "Implement Trie (Prefix Tree)",
    "leetcode_url": "https://leetcode.com/problems/Implement-Trie-(Prefix-Tree)/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n```\n    \n    The Trie data structure is implemented as a tree, where each node has a mapping of characters to their corresponding child nodes. Every node also has an `isEndOfWord` flag to indicate if any word ends at this node. \n\nThe `insert` function iterates through each character in a given word, adding new nodes to the tree if they don't already exist, and finally setting the `isEndOfWord` flag to true at the final node.\n\nThe `search` function follows the characters from the root of the Trie to the final node, returning false if any character does not map to a child node, otherwise returning the value of the `isEndOfWord` flag at the final node.\n\nThe `startsWith` function is similar to `search`, but returns true if a sequence of characters exists in the Trie, regardless of whether a word terminates at the final node.\n    "
}