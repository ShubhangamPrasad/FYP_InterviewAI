{
    "summary": "Find max sum of circular subarray",
    "question": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray. A circular array means the end connects to the beginning, and subarrays may only include each element at most once.",
    "example": "Input: nums = [1,-2,3,-2]; Output: 3\nInput: nums = [5,-3,5]; Output: 10\nInput: nums = [3,-1,2,-1]; Output: 4\nInput: nums = [3,-2,2,-3]; Output: 3\nInput: nums = [-2,-3,-1]; Output: -1",
    "constraint": "1 <= nums.length <= 3 * 10^4\n-3 * 10^4 <= nums[i] <= 3 * 10^4",
    "followup": "",
    "title": "Maximum Sum Circular Subarray",
    "leetcode_url": "https://leetcode.com/problems/Maximum-Sum-Circular-Subarray/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef reachableNodes(edges, maxMoves, n):\n    graph = [[] for _ in range(n)]\n    for u, v, cnt in edges:\n        graph[u].append((v, cnt + 1))\n        graph[v].append((u, cnt + 1))\n\n    visited = set()\n    pq = [(-maxMoves, 0)]\n\n    while pq:\n        moves_left, node = heappop(pq)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for next_node, moves_needed in graph[node]:\n            moves_left_after = moves_left - moves_needed\n            if next_node not in visited and moves_left_after > 0:\n                heappush(pq, (moves_left_after, next_node))\n\n    return len(visited)\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm.\n\n1. First, convert the given graph into an adjacency list (graph) so that it stores the adjacent nodes and the edge weights between them.\n2. Initialize a set (visited) for storing the visited nodes.\n3. Initialize a max-heap priority queue (pq), with the initial maximum moves left and the starting node (0) as a tuple.\n4. Run a while loop until the priority queue is empty:\n   a. Pop the top element from the queue which has the maximum moves left and the corresponding node.\n   b. Check if the node is already visited. If yes, continue to the next element in the queue.\n   c. If the node is not visited, add it to the visited set.\n   d. Loop through each neighbor of the current node:\n      i. Calculate moves_left_after: moves left after reaching the neighbor node.\n      ii. If the neighbor node is not visited and the moves_left_after is greater than 0, push it into the priority queue.\n5. Return the size of the visited set.\n    "
}