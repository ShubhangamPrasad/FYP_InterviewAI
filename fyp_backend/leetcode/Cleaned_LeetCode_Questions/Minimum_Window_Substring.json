{
    "summary": "Find minimum window substring",
    "question": "Given two strings s and t, return the smallest substring in s that contains all characters of t, including duplicates. If no such substring exists, return an empty string.",
    "example": "Example 1: Input: s = \"ADOBECODEBANC\", t = \"ABC\", Output: \"BANC\". Example 2: Input: s = \"a\", t = \"a\", Output: \"a\". Example 3: Input: s = \"a\", t = \"aa\", Output: \"\".",
    "constraint": "1 <= s.length, t.length <= 10^5. s and t consist of uppercase and lowercase English letters.",
    "followup": "Could you find an algorithm that runs in O(m + n) time?",
    "title": "Minimum Window Substring",
    "leetcode_url": "https://leetcode.com/problems/Minimum-Window-Substring/",
    "difficulty": "Hard",
    "starter_code": "\n    ```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    "
}