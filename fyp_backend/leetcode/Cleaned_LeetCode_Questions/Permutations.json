{
    "summary": "Find all array permutations",
    "question": "Given an array of distinct integers, return all possible permutations. The answer can be in any order.",
    "example": "Example 1: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3: Input: nums = [1] Output: [[1]]",
    "constraint": "1 <= nums.length <= 6, -10 <= nums[i] <= 10, all integers in nums are unique.",
    "followup": "",
    "title": "Permutations",
    "leetcode_url": "https://leetcode.com/problems/Permutations/",
    "difficulty": "Medium",
    "starter_code": "\n    ```python\nfrom typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results\n```\n    \n    The algorithm uses backtracking to generate all possible permutations. It works by swapping the elements in the input array in a recursive manner.\n\n1. The base case is when the index reaches the last element of the array; at this point, we append the current configuration to the \"results\" list.\n2. For each index, we iterate from `index` to the end of the array, performing the following steps:\n    a. Swap `index` and `i` elements.\n    b. Recursively call the helper function with `index + 1`.\n    c. Swap the elements back to their original positions.\n\nThis will generate all possible permutations, as it swaps elements in different positions while maintaining the original order in the input array. The termination condition for the recursion is the base case when we reach the end of the array. The complexity of this algorithm is O(N!), as there are N! permutations of an array of N elements.\n    "
}