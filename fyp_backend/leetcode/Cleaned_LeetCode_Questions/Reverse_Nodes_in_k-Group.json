{
    "summary": "Reverse linked list in k groups",
    "question": "Given a linked list, reverse its nodes in groups of k at a time while leaving remaining nodes intact. Only nodes may be rearranged, not their values.",
    "example": "Input: head = [1,2,3,4,5], k = 2; Output: [2,1,4,3,5]. Input: head = [1,2,3,4,5], k = 3; Output: [3,2,1,4,5]. Input: head = [1,2,3,4,5], k = 1; Output: [1,2,3,4,5]. Input: head = [1], k = 1; Output: [1].",
    "constraint": "1 <= sz <= 5000, 0 <= Node.val <= 1000, 1 <= k <= sz, Only O(1) memory for follow-up solution.",
    "followup": "Can the problem be solved in O(1) extra memory space?",
    "title": "Reverse Nodes In K-Group",
    "leetcode_url": "https://leetcode.com/problems/Reverse-Nodes-in-k-Group/",
    "difficulty": "Hard",
    "starter_code": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    "
}