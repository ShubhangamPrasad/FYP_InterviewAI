{
    "summary": "Find substring indices with words",
    "question": "Given a string s and an array of strings words, find all starting indices of substrings in s that are a concatenation of each word in words exactly once and without intervening characters.",
    "example": "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9]; Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: []; Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12]",
    "constraint": "1 <= s.length <= 10^4; s consists of lower-case English letters; 1 <= words.length <= 5000; 1 <= words[i].length <= 30; words[i] consists of lower-case English letters.",
    "followup": "",
    "title": "Substring With Concatenation Of All Words",
    "leetcode_url": "https://leetcode.com/problems/Substring-with-Concatenation-of-All-Words/",
    "difficulty": "Hard",
    "starter_code": "\n    ```python\nfrom collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    "
}