{
    "summary": "Calculate trapped rainwater volume",
    "question": "Given an elevation map as an array, compute the amount of water trapped after raining.",
    "example": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]; Output: 6. \nInput: height = [4,2,0,3,2,5]; Output: 9.",
    "constraint": "1 <= n <= 2 * 10^4, 0 <= height[i] <= 10^5, n == height.length.",
    "followup": "",
    "title": "Trapping Rain Water",
    "leetcode_url": "https://leetcode.com/problems/Trapping-Rain-Water/",
    "difficulty": "Hard",
    "starter_code": "\n    ```python\ndef trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    "
}